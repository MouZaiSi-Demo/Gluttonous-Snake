目前有两个思路

可以看出, 既然是操作格子, 也就是二维数组, 那么此时最短路径是曼哈顿距离

所以最短路问题可以用BFS加队列模拟来解决



类似于迷宫问题



但是如果BFS很容易产生什么身体把头包住的情况, 那真的有点人工智障



---

感觉没有比较好的算法处理哈密顿回路, 舍弃...

哈密顿回路的条件

1. 起点与终点相同
2. 每一步都有

----



思路：
实现分了两个部分，一是蛇的可以怎么走, 二是能不能这么走

所以这里我用了BFS
策略：

a.蛇如果吃了苹果后能找到自己的尾巴，才去吃这个苹果。

否则在头部找一个方向，这个方向满足 

1.离苹果最远距离（用的曼哈顿距离, 因为矩形距离, 话说曼哈顿距离还是我看唐人街探案看的.....）。2.走完后能找到尾巴。



b.如果吃了苹果后，生成的新苹果寻路算法无法找到这个新苹果。那么就在头部找一个方向，这个方向满足  

1.离苹果最远。2.走完后能找到尾巴。

经过我日思夜想, 发现以上两条策略可以处理蛇的所有死路的情况。

过程：
规划了一下(吸取教训)，先用一个list存蛇的身体的坐标，行走求解都单独完成。输出显示单独用一个method，先把蛇坐标装进邻接矩阵，然后输出邻接矩阵。


遇到的问题：
排除了一些很容易改掉的bug后，遇到了一些难改的问题
1.蛇在贴着尾巴走的时候会抛异常。
经排查是因为在执行“离苹果最远且能找到尾巴”这个策略的时候没有模拟行走。导致蛇身比行走前长，寻路算法无法找到路径。
模拟了一下就解决了

2.蛇会不时的，很白痴的，追着自己的尾巴原地绕圈而不去吃苹果，即使满足上述吃苹果的策略。
经排查发现是因为BFS寻路是找到的最短路。而在矩阵中距离相同最短路可以有很多条。而有的路径走法走了以后刚好使其不满足吃苹果后能找到尾巴的策略。
这个想了一下。后来把方向数组改了一下，改成了循环的方向，每次BFS的时候随机一次方向数组。使每次的找到的最短路不相同, 不同的话都能找到最短路。成功解决问题。
